#!/usr/bin/env bash
#
# `svn-backup2` is a frugal and minimalistic subversion backup solution.
# It generates and update just a single gzipped and sha256 checksumed file per repository.
# At first run it generates a full-backup and runs `svnadmin verify`
# The next runs append an incremental backup when there are changes. Before every append the
# backup integrity is checked.
#
# svn-backup2 is licensed under the MIT License
#
# Copyright (c) 2024 Jerry Jacobs <https://xor-gate.org>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Application is hosted at: https://github.com/xor-gate/svn-backup2
##
VERSION="0.1.2"
EXIT_CODE=0

###
# Fixed paths
###
SVNBACKUP2_CONFIG_FILE="/etc/svn-backup2.conf"
SVNBACKUP2_LOG_FILE="/var/log/svn-backup2.log"
SVNBACKUP2_BACKUP_STATE_PATH="/var/tmp/svn-backup2"

###
# Configuration defaults
###
SVNBACKUP2_CFG_REPOSITORIES_PATH="/srv/svn"
SVNBACKUP2_CFG_BACKUP_PATH="/srv/svn-backup2"

###
# Log to stdout and archive to file with datetime prefix
#
# $1: Logline
###
function log() {
	echo -e "[$(date)] $1" | tee -a ${SVNBACKUP2_LOG_FILE}
}

###
# Check and create paths
###
function check_and_create_paths() {
	if [ ! command -v svnadmin &> /dev/null ]; then
		log "ERROR: svnadmin not found in PATH, is subversion installed?"
		EXIT_CODE=1
		return
	fi

	if [ ! command -v svnlook &> /dev/null ]; then
		log "ERROR: svnlook not found in PATH, is subversion installed?"
		EXIT_CODE=1
		return
	fi

	if [ ! command -v sha256sum &> /dev/null ]; then
		log "ERROR: sha256sum not found in PATH, is coreutils installed?"
		EXIT_CODE=1
		return

	fi

	if [ ! command -v gzip &> /dev/null ]; then
		log "ERROR: gzip not found, is gzip installed?"
		EXIT_CODE=1
		return
	fi

	if [ ! -f ${SVNBACKUP2_LOG_FILE} ]; then
		touch ${SVNBACKUP2_LOG_FILE}
	fi

	if [ ! -d ${SVNBACKUP2_BACKUP_STATE_PATH} ]; then
		mkdir -p ${SVNBACKUP2_BACKUP_STATE_PATH}
		log "Created backup state directory ${SVNBACKUP2_BACKUP_STATE_PATH}"
	fi

	# Check if configuration file exists, or else create it with some defaults for convience
	if [ ! -f ${SVNBACKUP2_CONFIG_FILE} ]; then
		export SVNBACKUP2_CFG_REPOSITORIES_PATH
		export SVNBACKUP2_CFG_BACKUP_PATH

		env | grep SVNBACKUP2_CFG > ${SVNBACKUP2_CONFIG_FILE}
		log "Created configuration file with defaults at ${SVNBACKUP2_CONFIG_FILE}"
		cat ${SVNBACKUP2_CONFIG_FILE}
		log "NOTICE: Please run svn-backup2 again when configuration has been set"

		EXIT_CODE=1
		return
	fi

	# When the backup path doesn't exist create it
	if [ ! -d ${SVNBACKUP2_CFG_BACKUP_PATH} ]; then
		log "ERROR: Backup path doesn't exist ${SVNBACKUP2_CFG_BACKUP_PATH}"

		EXIT_CODE=1
		return
	fi

	# Check if repositories path exist
	if [ ! -d ${SVNBACKUP2_CFG_REPOSITORIES_PATH} ]; then
		log "ERROR: Repositories path doesn't exists at ${SVNBACKUP2_CFG_REPOSITORIES_PATH}"
		EXIT_CODE=1
		return
	fi
}

###
# Load global configuration file from $SVNBACKUP2_CONFIG_FILE
#
# Sets:
#  SVNBACKUP2_CFG_REPOSITORIES_PATH
#  SVNBACKUP2_CFG_BACKUP_PATH
###
function load_config_file() {
	set -a
	source ${SVNBACKUP2_CONFIG_FILE}
	set +a

	export SVNBACKUP2_CFG_REPOSITORIES_PATH
	export SVNBACKUP2_CFG_BACKUP_PATH
}

###
# Store the state of a single repository backup run.
# It will write all SVNBACKUP2_REPO_STATE_* vars to the repository state file
#
# Needs:
#  REPO_STATE_FILE
###
function repository_store_state() {
	export SVNBACKUP2_REPO_STATE_LAST_BACKUP_END_TIME=$(date +%s)
	env | grep SVNBACKUP2_REPO_STATE_ > "${REPO_STATE_FILE}"
}

###
# Load previous state of repository backup run
#
# Needs:
#  REPO_NAME
#  SVNBACKUP2_BACKUP_STATE_PATH
#  SVNBACKUP2_CFG_BACKUP_PATH
# Sets:
#  REPO_PATH
#  REPO_STATE_FILE
#  REPO_BACKUP_FILE
###
function repository_load_state() {
	export REPO_PATH="${SVNBACKUP2_CFG_REPOSITORIES_PATH}/${REPO_NAME}"
	export REPO_STATE_FILE="${SVNBACKUP2_BACKUP_STATE_PATH}/${REPO_NAME}.state"
	export REPO_BACKUP_FILE="${SVNBACKUP2_CFG_BACKUP_PATH}/${REPO_NAME}.svnbackup2"

	if [ ! -f ${REPO_STATE_FILE} ]; then
		return
	fi

	SVNBACKUP2_REPO_STATE_YOUNGEST=0
	source ${REPO_STATE_FILE}
}

###
# Check integrity of an existing repository backup
#
# Needs:
#  REPO_NAME
#  REPO_BACKUP_FILE
#  SVNBACKUP2_REPO_STATE_CHECKSUM
# Sets:
#  REPO_CHECKSUM_OK
###
function repository_backup_integrity_check() {
	REPO_CHECKSUM_OK=0

	if [ ! -f "${REPO_BACKUP_FILE}" ]; then
		log "Running svnadmin verify on database because this is the first time, this may take a while..."

		svnadmin verify "${REPO_PATH}" | tee ${SVNBACKUP2_LOG_FILE}

		if [ $? -eq 0 ]; then
			log "svnadmin verify succesfully"
		else
			log "ERROR: svnadmin verify failed"
		fi

		log "WARNING: No backup exists for ${REPO_NAME} repository, backup file integrity check skipped"

		return
	fi

	if [[ -z "${SVNBACKUP2_REPO_STATE_CHECKSUM}" ]]; then
		log "ERROR: Previous backup run didn't wrote checksum in the state file"
		return
	fi

	log "Checking integrity of backup file ${REPO_BACKUP_FILE}"
	REPO_CHECKSUM=$(sha256sum "${REPO_BACKUP_FILE}" | awk '{print $1;}')

	if [ "${REPO_CHECKSUM}" != "${SVNBACKUP2_REPO_STATE_CHECKSUM}" ]; then
		log "ERROR: Repository integrity check failed"
	else
		log "Repository checksum OK"
		REPO_CHECKSUM_OK=1
	fi
}

###
# Create checksum of repository backup file when REPO_BACKUP_FILE_CHANGED
#
# Needs:
#  REPO_NAME
#  REPO_BACKUP_FILE
#  REPO_BACKUP_FILE_CHANGED
# Sets:
#  SVNBACKUP2_REPO_STATE_CHECKSUM
###
function repository_backup_create_checksum() {
	if [ ! -f "${REPO_BACKUP_FILE}" ]; then
		log "WARNING: No backup created for repository \"${REPO_NAME}\", checksum skipped"
		return
	fi

	if [ $REPO_BACKUP_FILE_CHANGED = 1 ]; then
		log "Generating checksum for backup"
		SVNBACKUP2_REPO_STATE_CHECKSUM=$(sha256sum "${REPO_BACKUP_FILE}" | awk '{print $1;}')
	fi

	export SVNBACKUP2_REPO_STATE_CHECKSUM
}

###
# Lookup youngest subversion revision and check if a backup must be made
#
# Needs:
#  REPO_PATH
#  REPO_BACKUP_FILE
#  SVNBACKUP2_REPO_STATE_YOUNGEST
# Sets:
#  REPO_BACKUP_FILE_CHANGED
#  SVNBACKUP2_REPO_STATE_YOUNGEST
###
function repository_backup_subversion() {
	REPO_BACKUP_FILE_CHANGED=1
	YOUNGEST=$(svnlook youngest "${REPO_PATH}")

	log "Detected latest revision of repository is ${YOUNGEST}, backup has archived until revision ${SVNBACKUP2_REPO_STATE_YOUNGEST}"

	if [ ! -f ${REPO_BACKUP_FILE} ]; then
		log "No previous backup found, running full backup until revision ${YOUNGEST}"

		repository_backup_integrity_check

		log "Starting svnadmin dump, this can take a while..."
		svnadmin dump -q -r "0:${YOUNGEST}" "${REPO_PATH}" | gzip -c > "${REPO_BACKUP_FILE}" 2> /dev/null

		if [ $? = 0 ]; then
			log "svnadmin dump ok"
		else
			log "ERROR: something went wrong during svnadmin dump"
			EXIT_CODE=1
		fi
	elif [ ${YOUNGEST} = ${SVNBACKUP2_REPO_STATE_YOUNGEST} ]; then
		log "Backup already up to date"
		REPO_BACKUP_FILE_CHANGED=0
	else
		REV_FILTER="$(($SVNBACKUP2_REPO_STATE_YOUNGEST + 1)):${YOUNGEST}"

		repository_backup_integrity_check
		if [ ${REPO_CHECKSUM_OK} = 0 ]; then
			log "ERROR: incremental backup skipped due to previous integrity check failure"
			EXIT_CODE=1
			return
		fi

		log "Running incremental backup between revisions ${REV_FILTER}"
		svnadmin dump -q -r ${REV_FILTER} --incremental "${REPO_PATH}" | gzip -c >> "${REPO_BACKUP_FILE}" 2> /dev/null

		if [ $? = 0 ]; then
			log "svnadmin dump ok"
		else
			log "ERROR: something went wrong during svnadmin dump"
			EXIT_CODE=1
		fi
	fi

	export SVNBACKUP2_REPO_STATE_YOUNGEST=${YOUNGEST}
}

###
# Finish backup by printing how long it took for a single repository backup run
###
function repository_backup_finish() {
	REPO_BACKUP_TIME_DURATION_SEC=$(($SVNBACKUP2_REPO_STATE_LAST_BACKUP_START_TIME-$SVNBACKUP2_REPO_STATE_LAST_BACKUP_START_TIME))
	if [ $REPO_BACKUP_TIME_DURATION_SEC = 0 ]; then
		REPO_BACKUP_TIME_DURATION_SEC=1
	fi

	REPO_BACKUP_TIME_MIN=$(($REPO_BACKUP_TIME_DURATION_SEC / 60))
	REPO_BACKUP_TIME_SEC=$(($REPO_BACKUP_TIME_DURATION_SEC % 60))
	REPO_BACKUP_TIME="${REPO_BACKUP_TIME_MIN} minutes ${REPO_BACKUP_TIME_SEC} seconds"

	log "Finished backup of repository ${REPO_NAME}"
	log "Backup took ${REPO_BACKUP_TIME}"

	SVNBACKUP2_REPO_STATE_LAST_BACKUP_DURATION=${REPO_BACKUP_TIME_DURATION_SEC}
	export SVNBACKUP2_REPO_STATE_LAST_BACKUP_DURATION
}

###
# Backup a single repository
#
# $1: Name of the repository located in $SVNBACKUP2_CFG_REPOSITORIES_PATH
#
# Sets:
#  REPO_NAME
#  SVNBACKUP2_REPO_STATE_LAST_BACKUP_START_TIME
##
function repository_backup() {
	export REPO_NAME="$1"

	# Load previous state and check integrity
	repository_load_state

	export SVNBACKUP2_REPO_STATE_LAST_BACKUP_START_TIME="$(date +%s)"
	log "Starting backup of repository ${REPO_NAME}"

	# Create backup
	repository_backup_subversion
	repository_backup_create_checksum

	# Finalize backup
	repository_backup_finish
	repository_store_state
}

###
# Discover and backup all repositories in SVNBACKUP2_CFG_REPOSITORIES_PATH
###
function repositories_backup() {
	for repository in `ls -1 ${SVNBACKUP2_CFG_REPOSITORIES_PATH}`; do
		repository_path="${SVNBACKUP2_CFG_REPOSITORIES_PATH}/${repository}"

		# filter out only directories where the db folder is not present
		if [ ! -d "${repository_path}/db" ]; then
			continue
		fi

		repository_backup "${repository}"
	done
}

###
# Full backup operation from CLI
#
# $1: What to backup forced-full (e.g 'all' or '<repository name>')
###
function operation_full_backup() {
	what=$1

	if [ "${what}" = '' ]; then
		log "ERROR: Please specify 'all' or '<repository name>' to force full backup"
		EXIT_CODE=1
		return
	fi

	case ${what} in
		all)
			rm_filter="${SVNBACKUP2_CFG_BACKUP_PATH}/*.svnbackup2"
			log "Removing all old backups at ${rm_filter}"
			rm ${rm_filter} 
			repositories_backup
			;;
		*)
			rm_filter="${SVNBACKUP2_CFG_BACKUP_PATH}/${what}.svnbackup2"
			log "Removing backup at ${rm_filter}"
			rm  ${rm_filter}
			repository_backup "${what}"
			;;
	esac
}

###
# Help operation from CLI
###
function operation_help() {
	echo "Usage: svn-backup2 [operation] <args>"
	echo "  version                         Print the version"
	echo "  full [<repository name> | all]  Force full backup on repository or \"all\""
}


load_config_file

check_and_create_paths
if [ $EXIT_CODE != 0 ]; then
	exit ${EXIT_CODE}
fi

###
# Argparse
###
ARG_OPERATION=$1
case ${ARG_OPERATION} in
	help)
		operation_help
		;;
	version)
		echo ${VERSION}
		;;
	full)
		operation_full_backup $2
		;;
	*)
		repositories_backup
		;;
esac

exit ${EXIT_CODE}
